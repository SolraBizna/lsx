#include "lsx.h"

#include <stdio.h>
#include <string.h>

#include "lsx_test_common.h"

static const struct known_answer {
  const void* message;
  size_t msglen;
  uint8_t answer[SHA256_HASHBYTES];
} known_answers[] = {
#define KNOWN_ANSWER_STRING(str, ...) {str, sizeof(str)-1, {__VA_ARGS__}}
  /* Known answers from Wikipedia - http://en.wikipedia.org/wiki/SHA-2 */
  KNOWN_ANSWER_STRING("", 0xe3,0xb0,0xc4,0x42,0x98,0xfc,0x1c,0x14,0x9a,0xfb,0xf4,0xc8,0x99,0x6f,0xb9,0x24,0x27,0xae,0x41,0xe4,0x64,0x9b,0x93,0x4c,0xa4,0x95,0x99,0x1b,0x78,0x52,0xb8,0x55),
  KNOWN_ANSWER_STRING("The quick brown fox jumps over the lazy dog", 0xd7,0xa8,0xfb,0xb3,0x07,0xd7,0x80,0x94,0x69,0xca,0x9a,0xbc,0xb0,0x08,0x2e,0x4f,0x8d,0x56,0x51,0xe4,0x6d,0x3c,0xdb,0x76,0x2d,0x02,0xd0,0xbf,0x37,0xc9,0xe5,0x92),
  KNOWN_ANSWER_STRING("The quick brown fox jumps over the lazy dog.", 0xef,0x53,0x7f,0x25,0xc8,0x95,0xbf,0xa7,0x82,0x52,0x65,0x29,0xa9,0xb6,0x3d,0x97,0xaa,0x63,0x15,0x64,0xd5,0xd7,0x89,0xc2,0xb7,0x65,0x44,0x8c,0x86,0x35,0xfb,0x6c),
  /* Known answers of my own */
  KNOWN_ANSWER_STRING("This string has exactly 55 characters and no more, sir.", 0xa4,0xee,0x28,0x4e,0xb7,0x0a,0x91,0xa3,0xd0,0xf8,0x04,0x52,0x54,0xdf,0xe5,0x7a,0x50,0x01,0x4a,0xdf,0x1c,0x94,0x7a,0x59,0xe9,0xb0,0x33,0x6a,0x3c,0x51,0xcc,0x1c),
  KNOWN_ANSWER_STRING("This string has exactly 56 characters. Exactly 56 chars.", 0xdb,0xd4,0xdf,0x03,0x23,0xcd,0x71,0xeb,0x51,0x78,0x5f,0xfc,0x76,0x41,0xf3,0xfe,0xf1,0x03,0x29,0xfa,0x23,0x22,0x2f,0x4c,0xfb,0x3c,0x2b,0xc7,0x1b,0xa3,0xf5,0x2d),
  KNOWN_ANSWER_STRING("This string has exactly 64 characters. Exactly 64. No less, sir.", 0x2d,0x59,0x0e,0x7b,0xce,0x09,0x45,0x01,0x1f,0x4f,0xf7,0x83,0xe3,0x78,0xa4,0x82,0x99,0x19,0x78,0xf5,0x74,0x35,0x07,0xe0,0x8f,0xe6,0xb6,0x42,0xb0,0xaf,0x5e,0x35),
  KNOWN_ANSWER_STRING("This string has a good deal more than 64 characters. Exactly how many more?", 0x3c,0x37,0x0c,0xe0,0x39,0x4f,0xe3,0x78,0x48,0x2e,0xdd,0xa6,0x36,0x79,0x0a,0x6f,0x58,0xb3,0x24,0xe9,0xbb,0x94,0x30,0x91,0x89,0xf4,0x80,0xe7,0x8f,0x24,0xe0,0x04),
  KNOWN_ANSWER_STRING("Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.", 0x2c,0x7c,0x3d,0x5f,0x24,0x4f,0x1a,0x40,0x06,0x9a,0x32,0x22,0x42,0x15,0xe0,0xcf,0x9b,0x42,0x48,0x5c,0x99,0xd8,0x0f,0x35,0x7d,0x76,0xf0,0x06,0x35,0x9c,0x7a,0x18),
};

static int test_easyish(unsigned count) {
  int ret = 0;
  for(unsigned n = 0; n < elementcount(known_answers); ++n) {
    const struct known_answer* el = known_answers + n;
    uint8_t hash[SHA256_HASHBYTES];
    lsx_sha256_context ctx;
    lsx_setup_sha256(&ctx);
    const uint8_t* p = el->message;
    size_t rem = el->msglen;
    while(rem >= count) {
      lsx_input_sha256(&ctx, p, count);
      p += count; rem -= count;
    }
    if(rem > 0) lsx_input_sha256(&ctx, p, rem);
    lsx_finish_sha256(&ctx, hash);
    lsx_destroy_sha256(&ctx);
    if(memcmp(hash, el->answer, SHA256_HASHBYTES)) goto failure;
    continue;
  failure:
    fprintf(stderr, "SHA-256 (easy:%u) known answer %u failed!\n", count, n);
    fprintf(stderr, "datum | kn | re\n");
    for(unsigned i = 0; i < SHA256_HASHBYTES; ++i) {
      output_datum("h[%2u] | %02X | %02X\n", i, el->answer[i], hash[i]);
    }
    ret = 1;
  }
  return ret;
}

int main(int argc, char* argv[]) {
  (void)argc; (void)argv;
  int ret = 0;
  plain();
  /* test the easiest interface */
  for(unsigned n = 0; n < elementcount(known_answers); ++n) {
    const struct known_answer* el = known_answers + n;
    uint8_t hash[SHA256_HASHBYTES];
    lsx_calculate_sha256(el->message, el->msglen, hash);
    if(memcmp(hash, el->answer, SHA256_HASHBYTES)) goto easy_failed;
    continue;
  easy_failed:
    fprintf(stderr, "SHA-256 (lazy) known answer %u failed!\n", n);
    fprintf(stderr, "datum | kn | re\n");
    for(unsigned i = 0; i < SHA256_HASHBYTES; ++i) {
      output_datum("h[%2u] | %02X | %02X\n", i, el->answer[i], hash[i]);
    }
    ret = 1;
  }
  /* test the easyish interface with various byte increments */
  ret = ret || test_easyish(1);
  ret = ret || test_easyish(3);
  ret = ret || test_easyish(7);
  ret = ret || test_easyish(13);
  ret = ret || test_easyish(32);
  ret = ret || test_easyish(64);
  ret = ret || test_easyish(67);
  return ret;
}
