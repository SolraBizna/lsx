// we do this on purpose in at least one location, and it is safe on both x86
// and PPC
#pragma GCC diagnostic ignored "-Wformat-extra-args"

#include "lsx.h"

#include <stdio.h>
#include <string.h>

#include "gpg_twofish_tables.h"
#include "gen/twofish_tables.h"
#include "lsx_test_common.h"

/* from "ecb_ival.txt" */
static const struct ecb_ival_entry {
  void(*setup_func)(lsx_twofish_context* ctx, const uint8_t* in);
  const char* who;
  const uint8_t* in_key;
  const uint8_t in_pt[16], out_ct[16];
  uint32_t out_K[40];
} ecb_ival_entries[] = {
  {lsx_setup_twofish128, "128-bit key schedule",
   (const uint8_t[]){0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   {0x9F,0x58,0x9F,0x5C,0xF6,0x12,0x2C,0x32,0xB6,0xBF,0xEC,0x2F,0x2A,0xE8,0xC3,0x5A},
   {
     // Input whiten
     0x52C54DDE, 0x11F0626D, 0x7CAC9D4A, 0x4D1B4AAA,
     // Output whiten
     0xB7B83A10, 0x1E7D0BEB, 0xEE9C341F, 0xCFE14BE4,
     // Round subkeys
     0xF98FFEF9, 0x9C5B3C17, 0x15A48310, 0x342A4D81,
     0x424D89FE, 0xC14724A7, 0x311B834C, 0xFDE87320,
     0x3302778F, 0x26CD67B4, 0x7A6C6362, 0xC2BAF60E,
     0x3411B994, 0xD972C87F, 0x84ADB1EA, 0xA7DEE434,
     0x54D2960F, 0xA2F7CAA8, 0xA6B8FF8C, 0x8014C425,
     0x6A748D1C, 0xEDBAF720, 0x928EF78C, 0x0338EE13,
     0x9949D6BE, 0xC8314176, 0x07C07D68, 0xECAE7EA7,
     0x1FE71844, 0x85C05C89, 0xF298311E, 0x696EA672,
   }
  },
  {lsx_setup_twofish192, "192-bit key schedule",
   (const uint8_t[]){0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77},
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   {0xCF,0xD1,0xD2,0xE5,0xA9,0xBE,0x9C,0xDF,0x50,0x1F,0x13,0xB8,0x92,0xBD,0x22,0x48},
   {
     // Input whiten
     0x38394A24, 0xC36D1175, 0xE802528F, 0x219BFEB4,
     // Output whiten
     0xB9141AB4, 0xBD3E70CD, 0xAF609383, 0xFD36908A,
     // Round subkeys
     0x03EFB931, 0x1D2EE7EC, 0xA7489D55, 0x6E44B6E8,
     0x714AD667, 0x653AD51F, 0xB6315B66, 0xB27C05AF,
     0xA06C8140, 0x9853D419, 0x4016E346, 0x8D1C0DD4,
     0xF05480BE, 0xB6AF816F, 0x2D7DC789, 0x45B7BD3A,
     0x57F8A163, 0x2BEFDA69, 0x26AE7271, 0xC2900D79,
     0xED323794, 0x3D3FFD80, 0x5DE68E49, 0x9C3D2478,
     0xDF326FE3, 0x5911F70D, 0xC229F13B, 0xB1364772,
     0x4235364D, 0x0CEC363A, 0x57C8DD1F, 0x6A1AD61E,
   },
  },
  {lsx_setup_twofish256, "256-bit key schedule",
   (const uint8_t[]){0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF},
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   {0x37,0x52,0x7B,0xE0,0x05,0x23,0x34,0xB8,0x9F,0x0C,0xFC,0xCA,0xE8,0x7C,0xFA,0x20},
   {
     // Input whiten
     0x5EC769BF, 0x44D13C60, 0x76CD39B1, 0x16750474,
     // Output whiten
     0x349C294B, 0xEC21F6D6, 0x4FBD10B4, 0x578DA0ED,
     // Round subkeys
     0xC3479695, 0x9B6958FB, 0x6A7FBC4E, 0x0BF1830B,
     0x61B5E0FB, 0xD78D9730, 0x7C6CF0C4, 0x2F9109C8,
     0xE69EA8D1, 0xED99BDFF, 0x35DC0BBD, 0xA03E5018,
     0xFB18EA0B, 0x38BD43D3, 0x76191781, 0x37A9A0D3,
     0x72427BEA, 0x911CC0B8, 0xF1689449, 0x71009CA9,
     0xB6363E89, 0x494D9855, 0x590BBC63, 0xF95A28B5,
     0xFB72B4E1, 0x2A43505C, 0xBFD34176, 0x5C133D12,
     0x3A9247F7, 0x9A3331DD, 0xEE7515E6, 0xF0D54DCD,
   },
  },
};

/* from "ecb_tbl.txt" */
static const struct ecb_tbl_entry {
  void(*setup_func)(lsx_twofish_context* ctx, const uint8_t* in);
  const char* who;
  uint8_t first_ten_and_last_two[12][16];
} ecb_tbl_entries[] = {
  {lsx_setup_twofish128,"128-bit repeated encryption",
   {
     {0x9F,0x58,0x9F,0x5C,0xF6,0x12,0x2C,0x32,0xB6,0xBF,0xEC,0x2F,0x2A,0xE8,0xC3,0x5A},
     {0xD4,0x91,0xDB,0x16,0xE7,0xB1,0xC3,0x9E,0x86,0xCB,0x08,0x6B,0x78,0x9F,0x54,0x19},
     {0x01,0x9F,0x98,0x09,0xDE,0x17,0x11,0x85,0x8F,0xAA,0xC3,0xA3,0xBA,0x20,0xFB,0xC3},
     {0x63,0x63,0x97,0x7D,0xE8,0x39,0x48,0x62,0x97,0xE6,0x61,0xC6,0xC9,0xD6,0x68,0xEB},
     {0x81,0x6D,0x5B,0xD0,0xFA,0xE3,0x53,0x42,0xBF,0x2A,0x74,0x12,0xC2,0x46,0xF7,0x52},
     {0x54,0x49,0xEC,0xA0,0x08,0xFF,0x59,0x21,0x15,0x5F,0x59,0x8A,0xF4,0xCE,0xD4,0xD0},
     {0x66,0x00,0x52,0x2E,0x97,0xAE,0xB3,0x09,0x4E,0xD5,0xF9,0x2A,0xFC,0xBC,0xDD,0x10},
     {0x34,0xC8,0xA5,0xFB,0x2D,0x3D,0x08,0xA1,0x70,0xD1,0x20,0xAC,0x6D,0x26,0xDB,0xFA},
     {0x28,0x53,0x0B,0x35,0x8C,0x1B,0x42,0xEF,0x27,0x7D,0xE6,0xD4,0x40,0x7F,0xC5,0x91},
     {0x8A,0x8A,0xB9,0x83,0x31,0x0E,0xD7,0x8C,0x8C,0x0E,0xCD,0xE0,0x30,0xB8,0xDC,0xA4},
     {0x6B,0x45,0x92,0x86,0xF3,0xFF,0xD2,0x8D,0x49,0xF1,0x5B,0x15,0x81,0xB0,0x8E,0x42},
     {0x5D,0x9D,0x4E,0xEF,0xFA,0x91,0x51,0x57,0x55,0x24,0xF1,0x15,0x81,0x5A,0x12,0xE0}
   }
  },
  {lsx_setup_twofish192,"192-bit repeated encryption",
   {
     {0xEF,0xA7,0x1F,0x78,0x89,0x65,0xBD,0x44,0x53,0xF8,0x60,0x17,0x8F,0xC1,0x91,0x01},
     {0x88,0xB2,0xB2,0x70,0x6B,0x10,0x5E,0x36,0xB4,0x46,0xBB,0x6D,0x73,0x1A,0x1E,0x88},
     {0x39,0xDA,0x69,0xD6,0xBA,0x49,0x97,0xD5,0x85,0xB6,0xDC,0x07,0x3C,0xA3,0x41,0xB2},
     {0x18,0x2B,0x02,0xD8,0x14,0x97,0xEA,0x45,0xF9,0xDA,0xAC,0xDC,0x29,0x19,0x3A,0x65},
     {0x7A,0xFF,0x7A,0x70,0xCA,0x2F,0xF2,0x8A,0xC3,0x1D,0xD8,0xAE,0x5D,0xAA,0xAB,0x63},
     {0xD1,0x07,0x9B,0x78,0x9F,0x66,0x66,0x49,0xB6,0xBD,0x7D,0x16,0x29,0xF1,0xF7,0x7E},
     {0x3A,0xF6,0xF7,0xCE,0x5B,0xD3,0x5E,0xF1,0x8B,0xEC,0x6F,0xA7,0x87,0xAB,0x50,0x6B},
     {0xAE,0x81,0x09,0xBF,0xDA,0x85,0xC1,0xF2,0xC5,0x03,0x8B,0x34,0xED,0x69,0x1B,0xFF},
     {0x89,0x3F,0xD6,0x7B,0x98,0xC5,0x50,0x07,0x35,0x71,0xBD,0x63,0x12,0x63,0xFC,0x78},
     {0x16,0x43,0x4F,0xC9,0xC8,0x84,0x1A,0x63,0xD5,0x87,0x00,0xB5,0x57,0x8E,0x8F,0x67},
     {0xF0,0xAB,0x73,0x30,0x11,0x25,0xFA,0x21,0xEF,0x70,0xBE,0x53,0x85,0xFB,0x76,0xB6},
     {0xE7,0x54,0x49,0x21,0x2B,0xEE,0xF9,0xF4,0xA3,0x90,0xBD,0x86,0x0A,0x64,0x09,0x41}
   }
  },
  {lsx_setup_twofish256,"256-bit repeated encryption",
   {
     {0x57,0xFF,0x73,0x9D,0x4D,0xC9,0x2C,0x1B,0xD7,0xFC,0x01,0x70,0x0C,0xC8,0x21,0x6F},
     {0xD4,0x3B,0xB7,0x55,0x6E,0xA3,0x2E,0x46,0xF2,0xA2,0x82,0xB7,0xD4,0x5B,0x4E,0x0D},
     {0x90,0xAF,0xE9,0x1B,0xB2,0x88,0x54,0x4F,0x2C,0x32,0xDC,0x23,0x9B,0x26,0x35,0xE6},
     {0x6C,0xB4,0x56,0x1C,0x40,0xBF,0x0A,0x97,0x05,0x93,0x1C,0xB6,0xD4,0x08,0xE7,0xFA},
     {0x30,0x59,0xD6,0xD6,0x17,0x53,0xB9,0x58,0xD9,0x2F,0x47,0x81,0xC8,0x64,0x0E,0x58},
     {0xE6,0x94,0x65,0x77,0x05,0x05,0xD7,0xF8,0x0E,0xF6,0x8C,0xA3,0x8A,0xB3,0xA3,0xD6},
     {0x5A,0xB6,0x7A,0x5F,0x85,0x39,0xA4,0xA5,0xFD,0x9F,0x03,0x73,0xBA,0x46,0x34,0x66},
     {0xDC,0x09,0x6B,0xCD,0x99,0xFC,0x72,0xF7,0x99,0x36,0xD4,0xC7,0x48,0xE7,0x5A,0xF7},
     {0xC5,0xA3,0xE7,0xCE,0xE0,0xF1,0xB7,0x26,0x05,0x28,0xA6,0x8F,0xB4,0xEA,0x05,0xF2},
     {0x43,0xD5,0xCE,0xC3,0x27,0xB2,0x4A,0xB9,0x0A,0xD3,0x4A,0x79,0xD0,0x46,0x91,0x51},
     {0x43,0x10,0x58,0xF4,0xDB,0xC7,0xF7,0x34,0xDA,0x4F,0x02,0xF0,0x4C,0xC4,0xF4,0x59},
     {0x37,0xFE,0x26,0xFF,0x1C,0xF6,0x61,0x75,0xF5,0xDD,0xF4,0xC3,0x3B,0x97,0xA2,0x05}
   }
  },
};

int main(int argc, char* argv[]) {
  (void)argc; (void)argv;
  int ret = 0;
  ret = ret || test_8bit_table(gpg_q0, q0);
  ret = ret || test_8bit_table(gpg_q1, q1);
  ret = ret || test_8bit_table(gpg_poly_to_exp, rs_poly_to_exp);
  ret = ret || test_8bit_table(gpg_exp_to_poly, rs_poly_from_exp);
  ret = ret || test_32bit_table(gpg_mds[0], mdsq[0]);
  ret = ret || test_32bit_table(gpg_mds[1], mdsq[1]);
  ret = ret || test_32bit_table(gpg_mds[2], mdsq[2]);
  ret = ret || test_32bit_table(gpg_mds[3], mdsq[3]);
  for(unsigned n = 0; n < elementcount(ecb_ival_entries); ++n) {
    lsx_twofish_context ctx;
    const struct ecb_ival_entry* ent = ecb_ival_entries + n;
    ent->setup_func(&ctx, ent->in_key);
    uint8_t ct[16], pt[16];
    lsx_encrypt_twofish(&ctx, ent->in_pt, ct);
    lsx_decrypt_twofish(&ctx, ct, pt);
    if(memcmp(ct, ent->out_ct, 16)) goto ecb_ival_test_failed;
    if(memcmp(pt, ent->in_pt, 16)) goto ecb_ival_test_failed;
    for(int i = 0; i < 8; ++i) {
      if(ctx.W[i] != ent->out_K[i]) goto ecb_ival_test_failed;
    }
    for(int i = 0; i < 32; ++i) {
      if(ctx.K[i] != ent->out_K[i+8]) goto ecb_ival_test_failed;
    }
    lsx_destroy_twofish(&ctx); // be needlessly clean
    continue;
  ecb_ival_test_failed:
    fprintf(stderr, "ecb_ival %s failed!\n", ent->who);
    fprintf(stderr, "  datum |   known  |  result\n");
    for(int i = 0; i < 8; ++i) {
      output_datum("  K[%2i] | %08X | %08X\n",
                   i, ent->out_K[i], ctx.W[i]);
    }
    for(int i = 0; i < 32; ++i) {
      output_datum("  K[%2i] | %08X | %08X\n",
                   i+8, ent->out_K[i+8], ctx.K[i]);
    }
    lsx_destroy_twofish(&ctx);
    for(int i = 0; i < 16; ++i) {
      output_datum(" CT[%2i] |    %02X    |    %02X\n",
                   i, ent->out_ct[i], ct[i]);
    }
    for(int i = 0; i < 16; ++i) {
      output_datum(" PT[%2i] |    %02X    |    %02X\n",
                   i, ent->in_pt[i], pt[i]);
    }
    plain();
    ret = 1;
  }
  uint8_t key[32], ct[16], pt[16];
  for(unsigned n = 0; n < elementcount(ecb_tbl_entries); ++n) {
    lsx_twofish_context ctx;
    const struct ecb_tbl_entry* ent = ecb_tbl_entries + n;
    unsigned i;
    int known_index;
    memset(key, 0, sizeof(key));
    memset(pt, 0, sizeof(pt));
    for(i = 0; i < 49; ++i) {
      ent->setup_func(&ctx, key);
      lsx_encrypt_twofish(&ctx, pt, ct);
      switch(i) {
      case 0: case 1: case 2: case 3: case 4:
      case 5: case 6: case 7: case 8: case 9:
        known_index = i; break;
      case 47: known_index = 10; break;
      case 48: known_index = 11; break;
      default: known_index = -1;
      }
      if(known_index >= 0 &&
         memcmp(ct, ent->first_ten_and_last_two[known_index], 16))
        goto bad_result;
      memcpy(key+16, key, 16);
      memcpy(key, pt, 16);
      memcpy(pt, ct, 16);
    }
    lsx_destroy_twofish(&ctx);
    continue;
  bad_result:
    fprintf(stderr, "ecb_tbl %s failed after %u iterations!\n", ent->who, i+1);
    fprintf(stderr, "  datum | kn | re\n");
    for(int i = 0; i < 32; ++i) {
      output_datum("KEY[%2i] | %02X\n", i, key[i], key[i]);
    }
    for(int i = 0; i < 16; ++i) {
      output_datum(" PT[%2i] | %02X\n", i, pt[i], pt[i]);
    }
    for(int i = 0; i < 16; ++i) {
      output_datum(" CT[%2i] | %02X | %02X\n",
                   i, ent->first_ten_and_last_two[known_index][i], ct[i]);
    }
    lsx_destroy_twofish(&ctx);
    ret = 1;
  }
  plain();
  return ret;
}
